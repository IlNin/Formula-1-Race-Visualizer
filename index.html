<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html;charset=utf-8">
        <title>Formula 1 VA Project</title>
        <script type="text/javascript" src="d3.js" charset="utf-8"></script>
        <style>
            #title {
                border: 3px solid black;
                padding-left: 5px;
                padding-right: 5px;
                padding-bottom: 5px;
                display: inline-block;
                background: yellow;
                text-align: center;
            }
            #wrapper {
                display: flex;
                border: 3px solid black;
                border-top: 1px solid black;
                border-bottom: none;
                width: fit-content;
            }  
            #timeseries {
                display: inline-block;
            }
            #legendtable {
                display: inline-block;
            }
            #brushing {
                display: flex;
                border: 3px solid black;
                border-top: none;
                width: fit-content;
            }
        </style>
	</head>
    
    <body>
    <script charset="utf-8"> 
    // Global variables
    var container_dimensions = {width: 1200, height: 400}; // width: 650
    var margins = {top: 10, right: 20, bottom: 40, left: 40};
    var chart_dimensions = {
            width: container_dimensions.width - margins.left - margins.right,
            height: container_dimensions.height - margins.top - margins.bottom
    };
    var legend_width = 130;
    var brushing_container_height = 100;
    var brushing_height = brushing_container_height - margins.top - margins.bottom;
    
    var x, y, xAxis, yAxis, svg, line;
    var drivers, colors, lineData;
    
    // Draw the title above the charts
    function drawTitle() {
        // Creates the div 'title' which contains text, selections and buttons
        title = document.createElement('div');
        title.id = "title";
        title.innerHTML = "<h1>Formula 1 Visual Analytics Project</h1>";
        title.innerHTML += "Please select a race: ";
        document.body.appendChild(title);
    
        // Creates a selection for the seasons with a default option, and adds it to 'title'
        selectSeason = document.createElement('select');
        selectSeason.id = "select-season";
        defaultSeasonOption = document.createElement('option');
        defaultSeasonOption.value = 0;
        defaultSeasonOption.innerHTML = "- SEASON -";
        selectSeason.appendChild(defaultSeasonOption);
        title.appendChild(selectSeason);
        title.innerHTML += "&nbsp";
    
        // Creates a selection for the races with a default option, and adds it to 'title'
        selectRace = document.createElement('select');
        selectRace.id = "select-race";
        selectRace.style.width = '150px';
        defaultRaceOption = document.createElement('option');
        defaultRaceOption.value = 0;
        defaultRaceOption.innerHTML = "- RACE -";
        selectRace.appendChild(defaultRaceOption);
        title.appendChild(selectRace);
        title.innerHTML += "&nbsp";
    
        // Creates the search button, makes it disabled and adds it to 'title'
        search = document.createElement('button');
        search.id = "search";
        search.innerHTML = "Search data!";
        search.disabled = true;
        title.appendChild(search);
        
        // Loads the data from the csv file
        loadData();
    }
    
    // Loads the data from the csv file
    function loadData() {
        d3.csv("laps.csv", function(error, data) {
            // Prints the error in case something goes wrong
            if (error) {
                console.log(error);
            }
            // Everything goes ok!
            else {
                seasons = []; // Contains all distinct seasons inside the csv file
                data.forEach(function(d) { // Cycles through the data
                    // console.log(d);
                    d.surname = d.surname.replace(/[\s.']/g, '_'); // Removes eventual spaces in the surnames
                    if (d.surname == "Schumacher") { // Separetes Ralph and Michael Schumacher
                        d.surname = d.surname + "_" + d.forename[0];
                    }
                    if (!seasons.includes(d.year)) { // Check if the season is new
                        seasons.push(d.year); // Adds the season to the list
                        newSeasonOption = document.createElement('option'); // Makes the new season a selectable option 
                        newSeasonOption.value = d.year;
                        newSeasonOption.innerHTML = d.year;
                        document.getElementById("select-season").appendChild(newSeasonOption); // Adds the new option to the selection
                    }
                });
                activateInputEventsTitle(data); // Adds the events to the user's selections in the title now that the data is loaded
            }
        });
    }
    
    // Adds events to the user's selections in the title now that the data is loaded
    function activateInputEventsTitle(data) {
        document.getElementById("select-season").onchange = function() { // Checks if the user selects a season
            addRaces(data); // Adds the list of races belonging to that season to the races selection
        }    
        document.getElementById("select-race").onchange = function() { // Checks if the user selects a race
            isReady(); // Checks if to unlock the search button
        }
        search.onclick = function() { // Checks if the user clicks the search button
            plotTimeSeriesGraph(data, 
                document.getElementById("select-season").value, 
                document.getElementById("select-race").value) // Draws the data
        }
    }
    
    // Adds a list of races belonging to that season to the races selection
    function addRaces(data) {
        // RESTORE SELECTOR
        document.getElementById("search").disabled = true; // Disables the search button
        document.getElementById("select-race").value = 0; // Restore the race selector to the default option
        options = document.getElementById("select-race").options.length; // Removes all options inside the selector bar the default one
        for (i = options-1; i > 0; i--) {
            document.getElementById("select-race").options[i] = null;
        }
          
        // REFRESH SELECTOR
        year = document.getElementById("select-season").value; // Gets the year selected
        if (year > 0) { // A valid year, that is not the default option, is selected
            races = []; // Keeps track of unique races
            data.forEach(function(d) { // Goes through the data again to get all unique races for the year selected
                if (d.year == year && !races.includes(d.race)) {
                    races.push(d.race);
                    newRaceOption = document.createElement('option');
                    newRaceOption.value = d.round;
                    newRaceOption.innerHTML = d.race;
                    document.getElementById("select-race").appendChild(newRaceOption);
                }
            });   
        }
    }

    // Checks if to unlock the search button after the user has chosen a track
    function isReady() {
        if (document.getElementById("select-race").value > 0) {  // A valid race is selected: enables search button
            document.getElementById("search").disabled = false;
        }
        else { // Default option selected: disables search button
            document.getElementById("search").disabled = true;
        }
    }
    
    // Draws the graph that contains the timeseries lap/position
    function plotTimeSeriesGraph(data, year, round) {
        // Removes the previous graph
        previousGraph = document.getElementById("wrapper");
        if (document.body.contains(previousGraph)) {
            previousGraph.remove();
            document.getElementById("brushing").remove();
        }
        
        // Gets the relevant data
        relevantData = [];
        drivers = [];
        lineData = new Map();
        data.forEach(function(d) {
            if (d.year == year && d.round == round) {
                relevantData.push(d);
                if (!drivers.includes(d.surname)) {
                    driverData = [];
                    drivers.push(d.surname);
                    lineData.set(d.surname, driverData);
                }
                lineData.get(d.surname).push(d);
            }
        });
        
        // Initializes the wrapper and the empty svg area
        wrapper = document.createElement('div');
        wrapper.id = "wrapper";
        document.body.append(wrapper);
        
        svgDiv = document.createElement('div');
        svgDiv.id = "timeseries";
        wrapper.append(svgDiv);
        
        svg = d3.select('#timeseries')
            .append('svg')
                .attr("width", container_dimensions.width)
                .attr("height", container_dimensions.height)
                //.style("background-color", "red")
            .append("g")
                .attr("transform", "translate(" + margins.left + "," + margins.top + ")")
                .attr("id","timeseries");
        
        svg.append("defs") // Ensures data doesn't go over the axis when brushing
            .append("clipPath")
                .attr("id", "clip")
            .append("rect")
                .attr("width", chart_dimensions.width)
                .attr("height", chart_dimensions.height);
        
        // Initializes the scales and colors
        x = d3.scaleLinear()
            .domain(d3.extent(relevantData, function(d) {
                    return +d.lap;
                    }))
            .range([0, chart_dimensions.width])
            
        y = d3.scaleLinear()
            .domain(d3.extent(relevantData, function(d) {
                    return +d.position;
                    }))
            .range([0, chart_dimensions.height]);
        
        colors = d3.scaleOrdinal(d3.schemeCategory20);
            
        // Initializes the axis
        xAxis= d3.axisBottom(x).ticks().tickFormat(d3.format("d"));
        yAxis= d3.axisLeft(y).ticks(20).tickFormat(d3.format("d"));
        
        // Appends the x axis
        svg.append("g")
            .attr("class","x_axis")
            .attr("transform", "translate(0,"+(chart_dimensions.height+1)+")")
            .call(xAxis);
        svg.append("text")
            .attr("class","label")
            .attr("x", chart_dimensions.width)
            .attr("y", chart_dimensions.height+(margins.bottom-10))
            .style("text-anchor","end")
            .text("Laps");
        
        // Appends the y axis
        svg.append("g")
            .attr("class","y_axis")
            .call(yAxis)
        svg.append("text")
            .attr("class","label")
            .attr("transform","rotate(-90)")
            .attr("y", 6)
            .attr("dy","-1.5em")
            .style("text-anchor","end")
            .text("Position");
        
        // Populates the chart        
        svg.selectAll("circle")
            .data(relevantData)
            .enter()
            .append("circle")
                .attr("class", function(d) {
                    return "dot"+d.surname; 
                })
                .attr("r", 1)
                .attr("cx", function(d) { 
                    return x(d.lap);
                })
                .attr("cy", function(d) { 
                    return y(d.position);
                })
                .style("fill", function(d) {
                    return colors(d.surname); 
                })
                .attr("clip-path", "url(#clip)");
            
        // Draws the line that connects the points
        line = d3.line()
            .x(function(d){
                return x(d.lap)
            })
            .y(function(d){
                return y(d.position)
            })
            .curve(d3.curveLinear);
        for (i = 0; i < drivers.length; i++) {
            color = colors(drivers[i]);
            svg.append('path')
                .attr("class", "path"+drivers[i])
                .attr('d', line(lineData.get(drivers[i])))
                .attr("fill", "none")
                .attr("stroke-width", 1)
                .attr("stroke", color)
                .attr("clip-path", "url(#clip)");
        }
        
        // Draw the horizontal brushing
        drawHorizontalBrushing();
        
        // Draws the legend
        drawLegend();   
    }
    
    // Adds a horizontal brushing graph so that the user can zoom in/out on the timeseries
    function drawHorizontalBrushing() {
        // Initializes the empty svg area
        brushingDiv = document.createElement('div');
        brushingDiv.id = "brushing";
        document.body.append(brushingDiv);
        
        brushingSvg = d3.select('#brushing')
            .append('svg')
                .attr("width", container_dimensions.width + legend_width)
                .attr("height", brushing_container_height)
                //.style("background-color", "red")
            .append("g")
                .attr("transform", "translate(" + margins.left + "," + margins.top + ")")
                .attr("id","brushing");
                
        // Initializes the scales and colors
        brushingX = d3.scaleLinear()
            .domain(d3.extent(relevantData, function(d) {
                    return +d.lap;
                    }))
            .range([0, chart_dimensions.width])
            
        brushingY = d3.scaleLinear()
            .domain(d3.extent(relevantData, function(d) {
                    return +d.position;
                    }))
            .range([0, brushing_height]);
            
        // Initializes the axis
        brushingXAxis= d3.axisBottom(brushingX).ticks().tickFormat(d3.format("d"));
        
        // Appends the x axis
        brushingSvg.append("g")
            .attr("class", "brushing_x_axis")
            .attr("transform", "translate(0,"+(brushing_height+1)+")")
            .call(brushingXAxis);
        brushingSvg.append("text")
            .attr("class","label")
            .attr("x", chart_dimensions.width)
            .attr("y", brushing_height+(margins.bottom-10))
            .style("text-anchor","end")
            .text("Horizontal Brushing");
            
        // Draws the line that connects the points
        brushingLine = d3.line()
            .x(function(d){
                return brushingX(d.lap)
            })
            .y(function(d){
                return brushingY(d.position)
            })
            .curve(d3.curveLinear);
        for (i = 0; i < drivers.length; i++) {
            color = colors(drivers[i]);
            brushingSvg.append('path')
                .attr("class", "brushing_path"+drivers[i])
                .attr('d', brushingLine(lineData.get(drivers[i])))
                .attr("fill", "none")
                .attr("stroke-width", 1)
                .attr("stroke", color);
        }
        
        // Adds brushing to axis
        brush = d3.brushX()
            .extent([[0, 0], [chart_dimensions.width, brushing_height]])
            .on("brush", function() {
                // Gets the current selection
                selection = d3.event.selection;
                // Refreshes the x domain
                x.domain(selection.map(brushingX.invert, brushingX));
                // Refreshes the line
                line.x(function(d){
                        return x(d.lap)
                });
                // Refreshes the data on the timeseries
                for (i = 0; i < drivers.length; i++) {
                    svg.selectAll(".dot"+drivers[i])
                        .attr("cx", function(d) { 
                            return x(d.lap); 
                        })
                        .attr("cy", function(d) { 
                            return y(d.position); 
                        });
                    svg.select(".path"+drivers[i])
                        .attr("d", line(lineData.get(drivers[i]))); 
                }
                // Refreshes the x axis
                svg.select(".x_axis").call(xAxis);
            }); 
            
        // Adds brushing to axis
        brushingSvg.append("g")
            .attr("class", "brush")
            .call(brush)
            .call(brush.move, brushingX.range());  
    }
    
    // Draws the legend for the chart
    function drawLegend() {
        // Initializes the empty svg area
        wrapper = document.getElementById("wrapper");
        svgLegendDiv = document.createElement('div');
        svgLegendDiv.id = "legendtable";
        wrapper.append(svgLegendDiv);
        
        svgLegend = d3.select('#legendtable')
            .append('svg')
            .attr("width", legend_width)
            .attr("height", container_dimensions.height)
            //.style("background-color", "red")
            .append("g")
            .attr("transform", "translate(" + 0 + "," + margins.top + ")")
            .attr("id","legendtable");
          
        // Draws the small colored rectangles
        sizeSquare = 10;
        legend = svgLegend.selectAll("legend")
            .data(drivers)
            .enter()
            .append("g")
            .attr("class", "legend")
			.attr("transform", function(d,i){
                return "translate(0,"+(i*sizeSquare+i*6)+")";
            });
        legend.append("rect")
			.attr("width",sizeSquare)
			.attr("height",sizeSquare)
            .attr("class", function(d) {
                return "rect"+d;
            })
			.style("fill", function(d){
                return colors(d);
			})
            .on("click", function(d) { // User disables/enables data of a pilot in the graph
                filterChart(d);
            });
            
        // Writes the text near the small colored rectangles
        legend.append("text")
            .attr("class", function(d) {
                return "text"+d;
            })
            .attr("x", sizeSquare+5)
            .attr("y", sizeSquare/2)
            .attr("dy", ".35em")
            .text(function(d) {
                return d;
            })
            .on("click", function(d) { // User disables/enables data of a pilot in the graph
                filterChart(d);
            });
    }
    
    // Filters data on the chart thanks to user's input in the legend
    function filterChart(d) {
        console.log(d);
        // DISABLE
        if (d3.select(".path"+d).attr("visibility") == "visible") {
            d3.selectAll(".dot"+d)
                .attr("visibility", "hidden");
            d3.select(".path"+d)
                .attr("visibility", "hidden");
            d3.select(".brushing_path"+d)
                .attr("visibility", "hidden");
            d3.select(".text"+d)
                .style("fill", "grey");
            d3.select(".rect"+d)
                .style("fill", "grey");
        }
        // ENABLE
        else {
            d3.selectAll(".dot"+d)
                .attr("visibility", "visible");
            d3.select(".path"+d)
                .attr("visibility", "visible");
            d3.select(".brushing_path"+d)
                .attr("visibility", "visible");
            d3.select(".text"+d)
                .style("fill", "black");
            d3.select(".rect"+d)
                .style("fill", colors(d));
       }   
    }
        
    drawTitle();
    </script>
    </body>
</html>